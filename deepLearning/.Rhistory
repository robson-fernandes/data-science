score(fit, df.data)
plot(fit)
fitted <- bn.fit(fit, data = df.data, method="mle")
pred = predict(fitted, "venda", df.testeData)  # predicts the value of node C given test set
cbind(pred, df.testeData[,"venda"])
#Funcao Escala para Original
scaleToOriginal <- function(value,prediction){
s <- prediction
y.sd = sd(value)
y.mean = mean(value)
y.net = s * y.sd + y.mean
return(y.net)
}
#Converter Dados em valores originais
vendaOriginal <- test.setOriginal[,"venda"]
y.net = scaleToOriginal(vendaOriginal,pred)
result = cbind(vendaOriginal, y.net)
colnames(result) = c('Original', 'Previsto')
round(result, 4)
#mean absolute percentage error
mape <- mape(y = result[, 'Original'], yhat = result[, 'Previsto'])
mape*100
#Limpa workspace
ls()
rm(list=ls())
library(bnlearn)
library(forecast)
library(StatMeasures)
dados.grupos = read.table('dados-grupos.csv', header=TRUE, sep=";")
attach(dados.grupos)
dados.vendas = read.table('dados-vendas.csv', header=TRUE, sep=";")
attach(dados.vendas)
dados <-  cbind(dados.grupos$mes,
dados.grupos$quantidadeProduto,
dados.vendas$venda,
dados.grupos$grupoMilkShake,
dados.grupos$grupoSanduiche,
dados.grupos$grupoBebida,
dados.grupos$grupoAcompanhamento,
dados.grupos$grupoPrato,
dados.grupos$grupoAdicional,
dados.grupos$grupoBrinde,
dados.grupos$grupoItensComposicao)
colnames(dados) <- c("mes",
"quantidadeProduto",
"venda",
"grupoMilkShake",
"grupoSanduiche",
"grupoBebida",
"grupoAcompanhamento",
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
"grupoItensComposicao"
)
training.setOriginal <- dados[1:85, ]
training.set <- training.setOriginal
training.set[,"mes"] <- as.double(training.set[,"mes"])
training.set <- scale(training.set)
#conjunto de teste
test.setOriginal <- dados[85:90, ]
test.set = test.setOriginal
test.set$mes <- as.double(test.set$mes)
test.set <- scale(test.set)
#Nova Colecao
data = cbind(training.set[,"mes"],
training.set[,"quantidadeProduto"],
training.set[,"grupoMilkShake"],
training.set[,"grupoSanduiche"],
training.set[,"grupoBebida"],
training.set[,"grupoAcompanhamento"],
training.set[,"grupoPrato"],
training.set[,"grupoAdicional"],
training.set[,"venda"])
colnames(data) = c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
'venda')
testdata = test.set[,
c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
'venda')]
df.testeData = as.data.frame(testdata)
df.data = as.data.frame(data)
fit = tabu(df.data)
acyclic(fit)
directed(fit)
score(fit, df.data)
fit <- drop.arc(fit, "venda", "mes")
fit <- set.arc(fit, "mes", "venda")
fit <- set.arc(fit, "grupoMilkShake", "venda")
fit <- set.arc(fit, "grupoAcompanhamento", "venda")
plot(fit)
fitted <- bn.fit(fit, data = df.data, method="mle")
pred = predict(fitted, "venda", df.testeData)  # predicts the value of node C given test set
cbind(pred, df.testeData[,"venda"])
#Funcao Escala para Original
scaleToOriginal <- function(value,prediction){
s <- prediction
y.sd = sd(value)
y.mean = mean(value)
y.net = s * y.sd + y.mean
return(y.net)
}
#Converter Dados em valores originais
vendaOriginal <- test.setOriginal[,"venda"]
y.net = scaleToOriginal(vendaOriginal,pred)
result = cbind(vendaOriginal, y.net)
colnames(result) = c('Original', 'Previsto')
round(result, 4)
#mean absolute percentage error
mape <- mape(y = result[, 'Original'], yhat = result[, 'Previsto'])
mape*100
#Limpa workspace
ls()
rm(list=ls())
library(bnlearn)
library(forecast)
library(StatMeasures)
dados.grupos = read.table('dados-grupos.csv', header=TRUE, sep=";")
attach(dados.grupos)
dados.vendas = read.table('dados-vendas.csv', header=TRUE, sep=";")
attach(dados.vendas)
dados <-  cbind(dados.grupos$mes,
dados.grupos$quantidadeProduto,
dados.vendas$venda,
dados.grupos$grupoMilkShake,
dados.grupos$grupoSanduiche,
dados.grupos$grupoBebida,
dados.grupos$grupoAcompanhamento,
dados.grupos$grupoPrato,
dados.grupos$grupoAdicional,
dados.grupos$grupoBrinde,
dados.grupos$grupoItensComposicao)
colnames(dados) <- c("mes",
"quantidadeProduto",
"venda",
"grupoMilkShake",
"grupoSanduiche",
"grupoBebida",
"grupoAcompanhamento",
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
"grupoItensComposicao"
)
training.setOriginal <- dados[1:85, ]
training.set <- training.setOriginal
training.set[,"mes"] <- as.double(training.set[,"mes"])
training.set <- scale(training.set)
#conjunto de teste
test.setOriginal <- dados[85:90, ]
test.set = test.setOriginal
test.set$mes <- as.double(test.set$mes)
test.set <- scale(test.set)
#Nova Colecao
data = cbind(training.set[,"mes"],
training.set[,"quantidadeProduto"],
training.set[,"grupoMilkShake"],
training.set[,"grupoSanduiche"],
training.set[,"grupoBebida"],
training.set[,"grupoAcompanhamento"],
training.set[,"grupoPrato"],
training.set[,"grupoAdicional"],
training.set[,"grupoBrinde"],
training.set[,"venda"])
colnames(data) = c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
'venda')
testdata = test.set[,
c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
'venda')]
df.testeData = as.data.frame(testdata)
df.data = as.data.frame(data)
fit = rsmax2(df.data)
acyclic(fit)
directed(fit)
score(fit, df.data)
fit <- drop.arc(fit, "venda", "mes")
fit <- set.arc(fit, "mes", "venda")
fit <- set.arc(fit, "grupoMilkShake", "venda")
fit <- set.arc(fit, "grupoAcompanhamento", "venda")
plot(fit)
fitted <- bn.fit(fit, data = df.data, method="mle")
pred = predict(fitted, "venda", df.testeData)  # predicts the value of node C given test set
cbind(pred, df.testeData[,"venda"])
#Funcao Escala para Original
scaleToOriginal <- function(value,prediction){
s <- prediction
y.sd = sd(value)
y.mean = mean(value)
y.net = s * y.sd + y.mean
return(y.net)
}
#Converter Dados em valores originais
vendaOriginal <- test.setOriginal[,"venda"]
y.net = scaleToOriginal(vendaOriginal,pred)
result = cbind(vendaOriginal, y.net)
colnames(result) = c('Original', 'Previsto')
round(result, 4)
#mean absolute percentage error
mape <- mape(y = result[, 'Original'], yhat = result[, 'Previsto'])
mape*100
#Limpa workspace
ls()
rm(list=ls())
library(bnlearn)
library(forecast)
library(StatMeasures)
dados.grupos = read.table('dados-grupos.csv', header=TRUE, sep=";")
attach(dados.grupos)
dados.vendas = read.table('dados-vendas.csv', header=TRUE, sep=";")
attach(dados.vendas)
dados <-  cbind(dados.grupos$mes,
dados.grupos$quantidadeProduto,
dados.vendas$venda,
dados.grupos$grupoMilkShake,
dados.grupos$grupoSanduiche,
dados.grupos$grupoBebida,
dados.grupos$grupoAcompanhamento,
dados.grupos$grupoPrato,
dados.grupos$grupoAdicional,
dados.grupos$grupoBrinde,
dados.grupos$grupoItensComposicao)
colnames(dados) <- c("mes",
"quantidadeProduto",
"venda",
"grupoMilkShake",
"grupoSanduiche",
"grupoBebida",
"grupoAcompanhamento",
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
"grupoItensComposicao"
)
training.setOriginal <- dados[1:85, ]
training.set <- training.setOriginal
training.set[,"mes"] <- as.double(training.set[,"mes"])
training.set <- scale(training.set)
#conjunto de teste
test.setOriginal <- dados[85:90, ]
test.set = test.setOriginal
test.set$mes <- as.double(test.set$mes)
test.set <- scale(test.set)
#Nova Colecao
data = cbind(training.set[,"mes"],
training.set[,"quantidadeProduto"],
training.set[,"grupoMilkShake"],
training.set[,"grupoSanduiche"],
training.set[,"grupoBebida"],
training.set[,"grupoAcompanhamento"],
training.set[,"grupoPrato"],
training.set[,"grupoAdicional"],
training.set[,"grupoBrinde"],
training.set[,"venda"])
colnames(data) = c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
'venda')
testdata = test.set[,
c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
'venda')]
df.testeData = as.data.frame(testdata)
df.data = as.data.frame(data)
fit = rsmax2(df.data)
acyclic(fit)
directed(fit)
score(fit, df.data)
fit <- drop.arc(fit, "venda", "mes")
fit <- set.arc(fit, "mes", "venda")
fit <- set.arc(fit, "grupoMilkShake", "venda")
fit <- set.arc(fit, "grupoAcompanhamento", "venda")
plot(fit)
fitted <- bn.fit(fit, data = df.data, method="mle")
pred = predict(fitted, "venda", df.testeData)  # predicts the value of node C given test set
cbind(pred, df.testeData[,"venda"])
#Funcao Escala para Original
scaleToOriginal <- function(value,prediction){
s <- prediction
y.sd = sd(value)
y.mean = mean(value)
y.net = s * y.sd + y.mean
return(y.net)
}
#Converter Dados em valores originais
vendaOriginal <- test.setOriginal[,"venda"]
y.net = scaleToOriginal(vendaOriginal,pred)
result = cbind(vendaOriginal, y.net)
colnames(result) = c('Original', 'Previsto')
round(result, 4)
#mean absolute percentage error
mape <- mape(y = result[, 'Original'], yhat = result[, 'Previsto'])
mape*100
#Limpa workspace
ls()
rm(list=ls())
library(ggplot2)
library('neuralnet')
library(forecast)
library(StatMeasures)
dados.grupos = read.table('dados-grupos.csv', header=TRUE, sep=";")
attach(dados.grupos)
dados.vendas = read.table('dados-vendas.csv', header=TRUE, sep=";")
attach(dados.vendas)
dados <-  cbind(dados.grupos$mes,
dados.grupos$quantidadeProduto,
dados.vendas$venda,
dados.grupos$grupoMilkShake,
dados.grupos$grupoSanduiche,
dados.grupos$grupoBebida,
dados.grupos$grupoAcompanhamento,
dados.grupos$grupoPrato,
dados.grupos$grupoAdicional,
dados.grupos$grupoBrinde,
dados.grupos$grupoItensComposicao)
colnames(dados) <- c("mes",
"quantidadeProduto",
"venda",
"grupoMilkShake",
"grupoSanduiche",
"grupoBebida",
"grupoAcompanhamento",
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
"grupoItensComposicao"
)
training.setOriginal <- dados[1:85, ]
training.set <- training.setOriginal
training.set[,"mes"] <- as.double(training.set[,"mes"])
training.set <- scale(training.set)
#conjunto de teste
test.setOriginal <- dados[85:90, ]
test.set = test.setOriginal
test.set$mes <- as.double(test.set$mes)
test.set <- scale(test.set)
#Nova Colecao
data = cbind(training.set[,"mes"],
training.set[,"quantidadeProduto"],
training.set[,"grupoMilkShake"],
training.set[,"grupoSanduiche"],
training.set[,"grupoBebida"],
training.set[,"grupoAcompanhamento"],
training.set[,"grupoPrato"],
training.set[,"grupoAdicional"],
training.set[,"grupoBrinde"],
training.set[,"venda"])
colnames(data) = c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
'venda')
formula <- as.formula('venda  ~ mes +
quantidadeProduto +
grupoMilkShake +
grupoSanduiche +
grupoBebida +
grupoAcompanhamento +
grupoPrato +
grupoAdicional +
grupoBrinde')
fit = neuralnet(formula,
data=data,
linear.output=TRUE,
hidden=c(3,2),
threshold =0.01,
rep=5,
algorithm = "rprop+")
plot(fit,
col.entry="green",
col.hidden="blue",
col.out="red"
, rep="best")
testdata = test.set[,c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
'venda')]
#predicao
pred = compute(fit,testdata[,1:9])
index <-  1:9
escala <- scale(index)
result = cbind(escala[,1], pred$net.result, testdata[,"venda"])
colnames(result) = c('Attribute', 'Prediction', 'Actual')
round(result, 4)
# prepare data for plot
x = result[,"Attribute"]
y_act = result[,"Actual"]
y_pred = result[,"Prediction"]
par(mfrow=c(1,2))
# plot actual data
plot(x, y_act, pch=20, col=2, xlab='Attribute', ylab="Actual")
lines(x, y_act, col=8, lty=3, lwd=2)
# plot predict data
plot(x, y_pred, pch=20, col=1, xlab='Attribute', ylab="Predict")
lines(x, y_pred, col=8, lty=3, lwd=2)
#Converter Dados em valores originais
vendaOriginal <- test.setOriginal[,"venda"]
s <- pred$net.result
y.sd = sd(vendaOriginal)
y.mean = mean(vendaOriginal)
y.net = s * y.sd + y.mean
y.net
result = cbind(vendaOriginal, y.net)
colnames(result) = c('Original', 'Previsto')
round(result, 4)
#mean absolute percentage error
mape <- mape(y = result[, 'Original'], yhat = result[, 'Previsto'])
mape*100
fit = neuralnet(formula,
data=data,
linear.output=TRUE,
hidden=c(3,2),
threshold =0.01,
rep=5,
algorithm = "rprop+")
plot(fit,
col.entry="green",
col.hidden="blue",
col.out="red"
, rep="best")
testdata = test.set[,c('mes',
'quantidadeProduto',
'grupoMilkShake',
'grupoSanduiche',
'grupoBebida',
'grupoAcompanhamento',
"grupoPrato",
"grupoAdicional",
"grupoBrinde",
'venda')]
#predicao
pred = compute(fit,testdata[,1:9])
index <-  1:9
escala <- scale(index)
result = cbind(escala[,1], pred$net.result, testdata[,"venda"])
colnames(result) = c('Attribute', 'Prediction', 'Actual')
round(result, 4)
# prepare data for plot
x = result[,"Attribute"]
y_act = result[,"Actual"]
y_pred = result[,"Prediction"]
par(mfrow=c(1,2))
# plot actual data
plot(x, y_act, pch=20, col=2, xlab='Attribute', ylab="Actual")
lines(x, y_act, col=8, lty=3, lwd=2)
# plot predict data
plot(x, y_pred, pch=20, col=1, xlab='Attribute', ylab="Predict")
lines(x, y_pred, col=8, lty=3, lwd=2)
#Converter Dados em valores originais
vendaOriginal <- test.setOriginal[,"venda"]
s <- pred$net.result
y.sd = sd(vendaOriginal)
y.mean = mean(vendaOriginal)
y.net = s * y.sd + y.mean
y.net
result = cbind(vendaOriginal, y.net)
colnames(result) = c('Original', 'Previsto')
round(result, 4)
#mean absolute percentage error
mape <- mape(y = result[, 'Original'], yhat = result[, 'Previsto'])
mape*100
